/**
 * 
 */
package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.BaseMotorController;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;

import frc.robot.interfaces.*;
import frc.robot.commands.shooter.*;
import frc.robot.Robot;
//import frc.robot.sensors.Sonar;


/**
 * The {@code Shooter} class contains fields and methods pertaining to the function of the shooter.
 */
public class Shooter extends Subsystem implements IShooter{
	/**
	 * 
	 */
	static final double MAX_PCT_OUTPUT = 1.0;
	static final double ALMOST_MAX_PCT_OUTPUT = 1.0;
	static final double HALF_PCT_OUTPUT = 0.5;
	static final double REDUCED_PCT_OUTPUT = 0.6;
	
	static final int WAIT_MS = 1000;
	static final int TIMEOUT_MS = 5000;

	static final int TALON_TIMEOUT_MS = 20;

	static final int SHOOT_DISTANCE_INCHES = 17;
	
	BaseMotorController shooterLeft; 
	
	// shared shoot settings
	//private int onTargetCount; // counter indicating how many times/iterations we were on target
	//private final static int ON_TARGET_MINIMUM_COUNT = 25; // number of times/iterations we need to be on target to really be on target
	
	boolean isShooting;
	
	Robot robot;

	public static final int TICKS_PER_REVOLUTION = 2048; // TODO switch to 2048 if needed for Talon FX

	// move settings
	static final int PRIMARY_PID_LOOP = 0;

	static final int SLOT_0 = 0;

	static final double SHOOT_PROPORTIONAL_GAIN = 1.0;
	static final double SHOOT_INTEGRAL_GAIN = 0.001;
	static final double SHOOT_DERIVATIVE_GAIN = 20.0;
	static final double SHOOT_FEED_FORWARD = 1023.0/7200.0;

	public static final double TICK_PER_100MS_THRESH = 1;
	
	
	public Shooter(BaseMotorController shooterLeft_in, Robot robot_in) {
		
		shooterLeft = shooterLeft_in;
		
		robot = robot_in;

		shooterLeft.configFactoryDefault();
		
		// Mode of operation during Neutral output may be set by using the setNeutralMode() function.
		// As of right now, there are two options when setting the neutral mode of a motor controller,
		// brake and coast.
		shooterLeft.setNeutralMode(NeutralMode.Coast);

		/* Config sensor used for Primary PID [Velocity] */
        shooterLeft.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative,
				PRIMARY_PID_LOOP, TALON_TIMEOUT_MS); 

		// Sensor phase is the term used to explain sensor direction.
		// In order for limit switches and closed-loop features to function properly the sensor and motor has to be in-phase.
		// This means that the sensor position must move in a positive direction as the motor controller drives positive output.  
		shooterLeft.setSensorPhase(true);
		
		// Motor controller output direction can be set by calling the setInverted() function as seen below.
		// Note: Regardless of invert value, the LEDs will blink green when positive output is requested (by robot code or firmware closed loop).
		// Only the motor leads are inverted. This feature ensures that sensor phase and limit switches will properly match the LED pattern
		// (when LEDs are green => forward limit switch and soft limits are being checked).
		shooterLeft.setInverted(true);

		// Both the Talon SRX and Victor SPX have a follower feature that allows the motor controllers to mimic another motor controller's output.
		// Users will still need to set the motor controller's direction, and neutral mode.
		// The method follow() allows users to create a motor controller follower of not only the same model, but also other models
		// , talon to talon, victor to victor, talon to victor, and victor to talon.
		
		// set peak output to max in case if had been reduced previously
		setNominalAndPeakOutputs(MAX_PCT_OUTPUT);
	}
	
	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		setDefaultCommand(new ShooterStop());
	}

	@Override
	public void periodic() {
		// Put code here to be run every loop

	}

	public void shootHigh() {
		//shooterLeft.set(ControlMode.PercentOutput, +ALMOST_MAX_PCT_OUTPUT);

		setPIDParameters();
		setNominalAndPeakOutputs(MAX_PCT_OUTPUT); //this has a global impact, so we reset in stop()

		double RPM = 3000.0;

		double targetVelocity_UnitsPer100ms = RPM * 4096 / 600;

		shooterLeft.set(ControlMode.Velocity, targetVelocity_UnitsPer100ms);
		
		isShooting = true;
		//onTargetCount = 0;
	}

	public void shootLow() {
		//set(ControlMode.PercentOutput, +REDUCED_PCT_OUTPUT);

		setPIDParameters();
		setNominalAndPeakOutputs(MAX_PCT_OUTPUT); //this has a global impact, so we reset in stop()

		double RPM = 1500.0;

		double targetVelocity_UnitsPer100ms = RPM * 4096 / 600;

		shooterLeft.set(ControlMode.Velocity, targetVelocity_UnitsPer100ms);
		
		isShooting = true;
		//onTargetCount = 0;
	}
	
	public void stop() {
		shooterLeft.set(ControlMode.PercentOutput, 0);
		isShooting = false;
	}
	
	public void setPIDParameters()
	{
		shooterLeft.configAllowableClosedloopError(SLOT_0, TICK_PER_100MS_THRESH, TALON_TIMEOUT_MS);
		
		// P is the proportional gain. It modifies the closed-loop output by a proportion (the gain value)
		// of the closed-loop error.
		// P gain is specified in output unit per error unit.
		// When tuning P, it's useful to estimate your starting value.
		// If you want your mechanism to drive 50% output when the error is 4096 (one rotation when using CTRE Mag Encoder),
		// then the calculated Proportional Gain would be (0.50 X 1023) / 4096 = ~0.125.
		
		// I is the integral gain. It modifies the closed-loop output according to the integral error
		// (summation of the closed-loop error each iteration).
		// I gain is specified in output units per integrated error.
		// If your mechanism never quite reaches your target and using integral gain is viable,
		// start with 1/100th of the Proportional Gain.
		
		// D is the derivative gain. It modifies the closed-loop output according to the derivative error
		// (change in closed-loop error each iteration).
		// D gain is specified in output units per derivative error.
		// If your mechanism accelerates too abruptly, Derivative Gain can be used to smooth the motion.
		// Typically start with 10x to 100x of your current Proportional Gain.
			
		shooterLeft.config_kP(SLOT_0, SHOOT_PROPORTIONAL_GAIN, TALON_TIMEOUT_MS);
		shooterLeft.config_kI(SLOT_0, SHOOT_INTEGRAL_GAIN, TALON_TIMEOUT_MS);
		shooterLeft.config_kD(SLOT_0, SHOOT_DERIVATIVE_GAIN, TALON_TIMEOUT_MS);	
		shooterLeft.config_kF(SLOT_0, SHOOT_FEED_FORWARD, TALON_TIMEOUT_MS);
	}	
		
	// NOTE THAT THIS METHOD WILL IMPACT BOTH OPEN AND CLOSED LOOP MODES
	public void setNominalAndPeakOutputs(double peakOutput)
	{
		shooterLeft.configPeakOutputForward(peakOutput, TALON_TIMEOUT_MS);
		shooterLeft.configPeakOutputReverse(-peakOutput, TALON_TIMEOUT_MS);

		shooterLeft.configNominalOutputForward(0, TALON_TIMEOUT_MS);
		shooterLeft.configNominalOutputReverse(0, TALON_TIMEOUT_MS);
	}
	
	public boolean isShooting(){
		return isShooting;
	}

	// for debug purpose only
	public void joystickControl(Joystick joystick)
	{
		shooterLeft.set(ControlMode.PercentOutput, joystick.getY());
	}


	// in units per 100 ms
	public int getEncoderVelocity() {
		return (int) (shooterLeft.getSelectedSensorVelocity(PRIMARY_PID_LOOP));
	}

	// 1 min = 600 * 100 ms
	// 1 round = 4096 ticks
	public int getRpm() {
		return (int) (shooterLeft.getSelectedSensorVelocity(PRIMARY_PID_LOOP)*600/4096);
	}
}










